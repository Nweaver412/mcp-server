"""
Validator functions for Component Configuration data that are generated by agents.
"""

import json
import logging
from enum import Enum
from importlib import resources
from typing import Optional

import jsonschema
from jsonschema import Draft202012Validator, TypeChecker

from keboola_mcp_server.client import JsonDict

LOG = logging.getLogger(__name__)


RESOURCES = 'keboola_mcp_server.resources'


class ConfigurationSchemaResourceName(str, Enum):
    STORAGE = 'storage-schema.json'


class RecoverableValidationError(jsonschema.ValidationError):
    """
    An instance was invalid under a provided schema using a recoverable message for the Agent.
    """

    _RECOVERY_INSTRUCTIONS = (
        'Recovery instructions:\n'
        '- Please check the json schema.\n'
        '- Fix the errors in your input data to follow the schema.\n'
    )

    def __init__(self, *args, invalid_json: Optional[JsonDict] = None, initial_message: Optional[str] = None, **kwargs):
        super().__init__(*args, **kwargs)
        self.invalid_json = invalid_json
        self.initial_message = initial_message

    @classmethod
    def create_from_values(
        cls,
        other: jsonschema.ValidationError,
        invalid_json: Optional[JsonDict] = None,
        initial_message: Optional[str] = None,
    ):
        return cls(**other._contents(), invalid_json=invalid_json, initial_message=initial_message)

    def __str__(self) -> str:
        """
        Builds a string representation of the error with recovery instructions.
        Following points describe the order of the error message:
        - message = super().__str__() represents the original error message, so it starts with the error message.
        - message += initial_message if provided, it adds the initial message to the error message.
        - message += recovery instructions from _RECOVERY_INSTRUCTIONS
        - message += invalid_json if provided, it adds the invalid json input data to the error message.

        Example output (init_message="The provided storage configuration is not valid."):
            RecoverableValidationError: 'destination' is a required property
            ...parent error message (containing the violated part of the json schema)...

            The provided storage configuration is not valid.
            Recovery instructions:
            - Please check the json schema.
            - Fix the errors in your input data to follow the schema.

            Invalid input data:
            {
                "storage": {...}
            }
        """
        str_repr = f'{super().__str__()}\n'
        if self.initial_message:
            str_repr += f'{self.initial_message}\n'
        str_repr += f'{self._RECOVERY_INSTRUCTIONS}\n'
        if self.invalid_json:
            str_repr += f'\nInvalid input data:\n{json.dumps(self.invalid_json, indent=2)}\n'
        return str_repr.rstrip()


class KeboolaParametersValidator(Draft202012Validator):
    """
    A custom JSON Schema validator that:
    1. Supports a custom 'button' type by skipping it since it is a UI construct and not a data type.
    2. Normalizes the schema by correctly handling the 'required' keyword
       when it's misused within a property's definition. When a property has 'required' set to true, it is propagated
       up to the parent node required list.
    """

    CLASS_NAME = 'KeboolaParametersValidator'

    def __init__(self, schema: JsonDict, *args, **kwargs):
        super().__init__(schema, *args, **kwargs)
        # Set the custom type checker for this validator class
        self.type_checker = Draft202012Validator.TYPE_CHECKER.redefine(
            'button', KeboolaParametersValidator.skip_button_type
        )

    def validate(self, instance: object) -> None:
        super().validate(instance)

    @staticmethod
    def skip_button_type(checker: TypeChecker, instance: object) -> bool:
        """
        Dummy type checker for the button type.
        If there is a button in the schema, we skip it. As it is a UI construct and not a data type.
        :returns: True
        """
        return True


def validate_storage(storage: JsonDict, initial_message: Optional[str] = None) -> JsonDict:
    """Validate the storage configuration using jsonschema.
    :param storage: The storage configuration to validate
    :param initial_message: The initial message to include in the error message
    :returns: The validated storage configuration normalized to {"storage" : {...}}
    """
    schema = _load_schema(ConfigurationSchemaResourceName.STORAGE)
    # we expect the storage to be a dictionary of storage configurations with the "storage" key
    normalized_storage_data = {'storage': storage.get('storage', storage)}
    _validate_json_against_schema(
        json_data=normalized_storage_data,
        schema=schema,
        initial_message=initial_message,
    )
    return normalized_storage_data


def validate_parameters(parameters: JsonDict, schema: JsonDict, initial_message: Optional[str] = None) -> JsonDict:
    """
    Validate the parameters configuration using jsonschema.
    :parameters: json data to validate
    :schema: json schema to validate against (root or row parameter configuration schema)
    :initial_message: initial message to include in the error message
    :returns: The validated parameters configuration normalized to {"parameters" : {...}}
    """
    _validate_json_against_schema(
        json_data=parameters,
        schema=schema,
        initial_message=initial_message,
    )
    return {'parameters': parameters.get('parameters', parameters)}


def _validate_json_against_schema(json_data: JsonDict, schema: JsonDict, initial_message: Optional[str] = None):
    """Validate JSON data against the provided schema."""
    try:
        jsonschema.validate(instance=json_data, schema=schema)
    except jsonschema.ValidationError as e:
        raise RecoverableValidationError.create_from_values(e, invalid_json=json_data, initial_message=initial_message)
    except jsonschema.SchemaError as e:
        LOG.exception(
            f'The validation schema is not valid: {e}\n'
            f'initial_message: {initial_message}\n'
            f'schema: {schema}\n'
            f'json_data: {json_data}'
        )
        # this is not an Agent error, the schema is not valid and we are unable to validate the json
        # hence we continue with as if it was valid
        return


def _load_schema(json_schema_name: ConfigurationSchemaResourceName) -> JsonDict:
    with resources.open_text(RESOURCES, json_schema_name.value, encoding='utf-8') as f:
        return json.load(f)
