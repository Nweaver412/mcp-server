"""
Validator functions for Component Configuration data that are generated by agents.
"""

import json
import logging
from enum import Enum
from importlib import resources
from typing import Callable, Optional, cast

import jsonschema
from jsonschema import Draft202012Validator, TypeChecker
from jsonschema.validators import extend

from keboola_mcp_server.client import JsonDict, JsonPrimitive, JsonStruct

LOG = logging.getLogger(__name__)

ValidateFunction = Callable[[JsonDict, JsonDict], None]

RESOURCES = 'keboola_mcp_server.resources'


class ConfigurationSchemaResourceName(str, Enum):
    STORAGE = 'storage-schema.json'


class RecoverableValidationError(jsonschema.ValidationError):
    """
    An instance was invalid under a provided schema using a recoverable message for the Agent.
    """

    _RECOVERY_INSTRUCTIONS = (
        'Recovery instructions:\n'
        '- Please check the json schema.\n'
        '- Fix the errors in your input data to follow the schema.\n'
    )

    def __init__(self, *args, invalid_json: Optional[JsonDict] = None, initial_message: Optional[str] = None, **kwargs):
        super().__init__(*args, **kwargs)
        self.invalid_json = invalid_json
        self.initial_message = initial_message

    @classmethod
    def create_from_values(
        cls,
        other: jsonschema.ValidationError,
        invalid_json: Optional[JsonDict] = None,
        initial_message: Optional[str] = None,
    ):
        return cls(**other._contents(), invalid_json=invalid_json, initial_message=initial_message)

    def __str__(self) -> str:
        """
        Builds a string representation of the error with recovery instructions.
        Following points describe the order of the error message:
        - message = super().__str__() represents the original error message, so it starts with the error message.
        - message += initial_message if provided, it adds the initial message to the error message.
        - message += recovery instructions from _RECOVERY_INSTRUCTIONS
        - message += invalid_json if provided, it adds the invalid json input data to the error message.

        Example output (init_message="The provided storage configuration is not valid."):
            RecoverableValidationError: 'destination' is a required property
            ...parent error message (containing the violated part of the json schema)...

            The provided storage configuration is not valid.
            Recovery instructions:
            - Please check the json schema.
            - Fix the errors in your input data to follow the schema.

            Invalid input data:
            {
                "storage": {...}
            }
        """
        str_repr = f'{super().__str__()}\n'
        if self.initial_message:
            str_repr += f'{self.initial_message}\n'
        str_repr += f'{self._RECOVERY_INSTRUCTIONS}\n'
        if self.invalid_json:
            str_repr += f'\nInvalid input data:\n{json.dumps(self.invalid_json, indent=2)}\n'
        return str_repr.rstrip()


class KeboolaParametersValidator:
    """
    A custom JSON Schema validator that:
    1. Supports a custom 'button' type by skipping it since it is a UI construct and not a data type.
    2. Normalizes the schema by correctly handling the 'required' keyword
       when it's misused within a property's definition. When a property has 'required' set to true or false, we
       set it to an empty list.
    """

    @classmethod
    def validate(cls, instance: JsonDict, schema: JsonDict) -> None:
        """
        Validate the instance against the schema.
        """
        normalized_schema = cls.normalize_schema(schema)
        type_checker = Draft202012Validator.TYPE_CHECKER.redefine('button', cls.skip_button_type)
        validator = extend(Draft202012Validator, type_checker=type_checker)(normalized_schema)
        return validator.validate(instance)

    @staticmethod
    def skip_button_type(checker: TypeChecker, instance: object) -> bool:
        """
        Dummy type checker for the button type.
        If there is a button in the schema, we skip it. As it is a UI construct and not a data type.
        :returns: True
        """
        return True

    @staticmethod
    def normalize_schema(schema: JsonDict) -> JsonDict:
        """Normalize schema by converting required fields to lists"""

        def _convert_required(schema: JsonStruct | JsonPrimitive) -> JsonStruct | JsonPrimitive:
            if not isinstance(schema, dict):
                return schema

            required = schema.get('required', None)
            if required is not None:
                # we convert true and false to empty list since the schema expects a list
                # We expect: The parent node's required list should include all properties marked as required=true
                # in its children
                schema['required'] = required if isinstance(required, list) else []
            else:
                schema.pop('required', None)

            if properties := cast(JsonDict, schema.get('properties')):
                schema['properties'] = {
                    field_name: _convert_required(field_schema) for field_name, field_schema in properties.items()
                }
            return schema

        return cast(JsonDict, _convert_required(schema))


def validate_storage(storage: JsonDict, initial_message: Optional[str] = None) -> JsonDict:
    """Validate the storage configuration using jsonschema.
    :param storage: The storage configuration to validate
    :param initial_message: The initial message to include in the error message
    :returns: The validated storage configuration normalized to {"storage" : {...}}
    """
    schema = _load_schema(ConfigurationSchemaResourceName.STORAGE)
    # we expect the storage to be a dictionary of storage configurations with the "storage" key
    normalized_storage_data = {'storage': storage.get('storage', storage)}
    _validate_json_against_schema(
        json_data=normalized_storage_data,
        schema=schema,
        initial_message=initial_message,
    )
    return normalized_storage_data


def validate_parameters(parameters: JsonDict, schema: JsonDict, initial_message: Optional[str] = None) -> JsonDict:
    """
    Validate the parameters configuration using jsonschema.
    :parameters: json data to validate
    :schema: json schema to validate against (root or row parameter configuration schema)
    :initial_message: initial message to include in the error message
    :returns: The validated parameters configuration normalized to {"parameters" : {...}}
    """
    _validate_json_against_schema(parameters, schema, initial_message, KeboolaParametersValidator.validate)

    return {'parameters': parameters.get('parameters', parameters)}


def _validate_json_against_schema(
    json_data: JsonDict,
    schema: JsonDict,
    initial_message: Optional[str] = None,
    validate_fn: Optional[ValidateFunction] = None,
):
    """Validate JSON data against the provided schema."""
    try:
        validate_fn = validate_fn or jsonschema.validate
        validate_fn(json_data, schema)
    except jsonschema.ValidationError as e:
        raise RecoverableValidationError.create_from_values(e, invalid_json=json_data, initial_message=initial_message)
    except jsonschema.SchemaError as e:
        LOG.exception(
            f'The validation schema is not valid: {e}\n'
            f'initial_message: {initial_message}\n'
            f'schema: {schema}\n'
            f'json_data: {json_data}'
        )
        # this is not an Agent error, the schema is not valid and we are unable to validate the json
        # hence we continue with as if it was valid
        return


def _load_schema(json_schema_name: ConfigurationSchemaResourceName) -> JsonDict:
    with resources.open_text(RESOURCES, json_schema_name.value, encoding='utf-8') as f:
        return json.load(f)
